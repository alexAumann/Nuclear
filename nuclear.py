import re
import numpy as np
from isotope import ion


# size of the cycle should be the number of distinct isotopes

class Nuclear:
    # redo this so it's aligned with other conventions
    # [ng, -ng, pn, -pn, beta, beta+, pg, -pg, ap, -ap, an, -an, ag, -ag]
    # [N, Z, A] for sublist
    # all forward reactions
    # two stable nuclei with Z > N?
    # positive indicates capture
    # negative indicates emission
    # TODO Extract mass fractions
    reactions = [[1, 0, 1], [-1, 0, -1],
                 # have (p,n) reactions at a later time
                 [-1, 1, 0], [1, -1, 0],
                 [0, 1, 1], [0, -1, -1],
                 [2, 1, 3], [-2, -1, -3],
                 [1, 2, 3], [-1, -2, -3],
                 [2, 2, 4], [-2, -2, -4]]
    # This is a crude implementation for the nuclear reactions
    ng = {str([1, 0, 1]): [-1, 0, 0], str([-1, 0, -1]): [1, 0, 0]}
    # pn = [[-1, 1, 0], [1, -1, 0]]
    # neutron proton alpha
    beta = {str([-1, 1, 0]): [1, -1, 0], str([1, -1, 0]): [-1, 1, 0]}
    pg = {str([0, 1, 1]): [0, -1, 0], str([0, -1, -1]): [0, 1, 0]}
    ap = {str([2, 1, 3]): [0, 1, -1], str([-2, -1, -3]): [0, -1, 1]}
    an = {str([1, 2, 3]): [1, 0, -1], str([-1, -2, -3]): [0, -1, 1]}
    ag = {str([2, 2, 4]): [0, 0, -1], str([-2, -2, -4]): [0, 0, 1]}
    neutron = [[1, 0, 1], [-1, 0, -1], [1, 2, 3], [-1, -2, -3], [-1, 1, 0], [1, -1, 0]]
    proton = [[0, 1, 1], [0, -1, -1], [2, 1, 3], [-2, -1, -3], [-1, 1, 0], [1, -1, 0]]
    alpha = [[2, 1, 3], [-2, -1, -3], [1, 2, 3], [-1, -2, -3], [2, 2, 4], [-2, -2, -4]]

    def __init__(self, data):
        """
        :param data: .flowb data generated by the Shot class
        """
        self.data = data.splitlines()
        self.nuc_change = [0, 0, 0]

    @staticmethod
    def str_to_float(val):
        """
        Ensures that numerical data is in the appropriate format

        :param val: A string to be converted into numerical data of proper form
        :return:
        """
        return float(re.sub(r"(\d)([+-])", r"\1E\2", val))

    def check_nucleus(self):
        result = []
        if self.nuc_change in self.neutron:
            result.append(0)
        if self.nuc_change in self.proton:
            result.append(1)
        if self.nuc_change in self.alpha:
            result.append(2)
        if len(result):
            return result
        else:
            raise Exception("Change in nucleus may be incorrect:", str(self.nuc_change))

    def check_priority(self):
        if self.nuc_change[1] < 0 or self.nuc_change[2] < 0:
            return 1
        else:
            return 0

    @staticmethod
    def order_iso(lst, cycle=1):
        """
        This method returns a list which is ordered by nucleus of lower Z or lower A, in the priority

        :param lst: A lst of strings which represent elements, for example
            ['C12', 'N13', 'C13', 'N14', 'O15', 'N15', 'C12']
        :param cycle: cycle = 1 implies that this is a cycle, cycle = 0 implies that
            this is not a cycle
        :return: returns a list which is ordered by nucleus of lower Z or lower A, in the priority
        """
        if cycle == 1 and lst[0] != lst[-1]:
            raise Exception("This is not a cycle")
        if cycle != 0 and cycle != 1:
            raise ValueError("Cycle can only have value of 1 or 0")
        output = lst[:None if cycle == 0 else -cycle]
        output = sorted(output, key=lambda x: (ion(x).Z, ion(x).A))
        return output

    # coefficients of the exponential terms haven't been determined yet
    def create_soln(self, eig_val, eig_vec, size, t):
        """
        A helper method which creates the time dependent solution from the eigenvector analysis of nuclear reaction
         cycles. This is done by recursion.

        :param eig_val: List of eigenvalues. Eigenvalues and eigenvectors need to occupy the same position in the list.
        :param eig_vec: List of eigenvectors. Eigenvalues and eigenvectors need to occupy the same position in the list.
        :param size: The size of the cycle i.e., how many distinct isotopes are there in the cycle?
        :param t: A parameter which represents time in ... . This parameter needn't be defined when creating the
            solution function
        :return: returns the time dependent solution.
        """
        if size == 0:
            return eig_vec[:, size] * np.exp(eig_val[size] * t)
        else:
            return eig_vec[:, size] * np.exp(eig_val[size] * t) + self.create_soln(eig_val, eig_vec, size - 1, t)

    def get_mass_fractions(self):
        """
        Extracts the mass fractions from the attribute data.
        :return: the mass fractions as a list of strings.
        """
        mass_fractions = None
        index = None
        for i, l in enumerate(self.data):
            if l.find('MASS FRACTIONS') > 0:
                index = i + 1
            if l.find('PARTITION FUNCTION') > 0:
                mass_fractions = self.data[index:i]
                break
        mass_fractions = [i for i in mass_fractions for i in i.split() if len(i) > 0]
        return mass_fractions[:len(mass_fractions)]

    # Flows aren't extracted properly as some entries in the same row aren't separated by ' '
    def get_flows(self):
        """
        Extracts the === FLOWS === data from the attribute data.
        :return: the flow data as a list.
        """
        flows = None
        index = None
        for i, l in enumerate(self.data):
            if l.find('== FLOWS ==') > 0:
                index = i + 1
            if l.find('== RATES ==') > 0:
                flows = self.data[index:i]
                break
        flows = [i.split() for i in flows if len(i) > 0]
        flows[2].insert(1, '')  # to be changed
        return flows[:len(flows) - 1]

    def get_rates(self):
        """
        Extracts the === RATES === data from the attribute data
        :return: the rates data as a list
        """
        rates = None
        for i, l in enumerate(self.data):
            if l.find('== RATES ==') > 0:
                rates = self.data[i + 1:]
                break
        rates = [i.split() for i in rates if len(i) > 0]
        return rates

    def check_rates(self):
        """
        Function which checks if there are any outstanding errors with the forward and reverse rates
        :return: Returns a string if there are no errors, otherwise returns a list of the errors
        """
        rates = self.get_rates()
        check = []
        for elem in rates[2:-1]:
            for i in range(7):
                if self.str_to_float(elem[1 + 2 * i]) - \
                        self.str_to_float(elem[2 + 2 * i]) > self.str_to_float(elem[1 + 2 * i]):
                    check.append(elem)
        if len(check) == 0:
            return "No critical errors"
        else:
            return check

    # may expand this to incorporate any CNO cycle
    def construct_cno1_mat(self):
        # ignores (p, n) reactions, will add a default argument for this later
        cno1 = ['C12', 'N13', 'C13', 'N14', 'O15', 'N15', 'C12']
        ordering = self.order_iso(cno1)
        rate_mat = np.zeros((6, 6))
        # gets rid of n-p reactions
        rates = np.delete(np.array(self.get_rates()[1:]), [3, 4], 1)
        for n in range(6):
            # looks at the change in nucleus (final - initial)
            self.nuc_change[0] = ion(cno1[n + 1]).N - ion(cno1[n]).N
            self.nuc_change[1] = ion(cno1[n + 1]).Z - ion(cno1[n]).Z
            self.nuc_change[2] = ion(cno1[n + 1]).A - ion(cno1[n]).A
            # checks for lower Z, then lower A
            # looks at the next isotope for reaction information with i = 1
            i = self.check_priority()
            for elem in rates:  # I could extract the rates?
                if elem[0] == ion(cno1[n + i]):
                    i = ordering.index(cno1[n + 1])
                    j = ordering.index(cno1[n])  # creates diagonal of matrix
                    rate_mat[j, j] = -self.str_to_float(elem[self.reactions.index(self.nuc_change) + 1])
                    rate_mat[i, j] = self.str_to_float(elem[self.reactions.index(self.nuc_change) + 1])
                    break
        return rate_mat

    # considers only basic reaction atm ?
    # format is [ng, -ng, pn, -pn, beta, -beta, pg, -pg, ap, -ap, an, -an, ag, -ag]
    # have to worry about branching at some point
    # make function which make the matrix
    # get another function to do eigen_check

    def construct_rate_mat(self, cycle):
        """
        :param cycle: List of strings which indicates the cycle, for example
            ['C12', 'N13', 'C13', 'N14', 'O15', 'N15', 'C12']
        :return: eigenvalues and eigenvectors?
        """
        ordering = self.order_iso(cycle)
        rate_mat = np.zeros((len(ordering), len(ordering)))
        rates = np.delete(np.array(self.get_rates()[1:]), [3, 4], 1)
        for n in range(len(ordering)):
            # looks at the change in nucleus (final - initial)
            self.nuc_change[0] = ion(cycle[n + 1]).N - ion(cycle[n]).N
            self.nuc_change[1] = ion(cycle[n + 1]).Z - ion(cycle[n]).Z
            self.nuc_change[2] = ion(cycle[n + 1]).A - ion(cycle[n]).A
            # checks for lower Z, then lower A
            # looks at the next isotope for reaction information with i = 1
            i = self.check_priority()
            for elem in rates:  # I could extract the rates?
                if elem[0] == ion(cycle[n + i]):
                    i = ordering.index(cycle[n + 1])
                    j = ordering.index(cycle[n])  # creates diagonal of matrix
                    rate_mat[j, j] = -self.str_to_float(elem[self.reactions.index(self.nuc_change) + 1])
                    rate_mat[i, j] = self.str_to_float(elem[self.reactions.index(self.nuc_change) + 1])
                    break
        return rate_mat

    def construct_rate_mat_2(self, cycle):
        """
        :param cycle: List of strings which indicates the cycle, for example
            ['C12', 'N13', 'C13', 'N14', 'O15', 'N15', 'C12']
        :return: eigenvalues and eigenvectors?
        """
        ordering = self.order_iso(cycle, cycle=0)
        rate_mat = np.zeros((len(ordering), len(ordering)))
        rates = np.delete(np.array(self.get_rates()[1:]), [3, 4], 1)
        for m in range(len(ordering)):
            for n in range(len(ordering)):
                # looks at the change in nucleus (final - initial)
                self.nuc_change[0] = ion(cycle[n]).N - ion(cycle[m]).N
                self.nuc_change[1] = ion(cycle[n]).Z - ion(cycle[m]).Z
                self.nuc_change[2] = ion(cycle[n]).A - ion(cycle[m]).A
                # checks for lower Z, then lower A
                # looks at the next isotope for reaction information with i = 1
                if self.nuc_change in self.reactions:
                    i = self.check_priority()
                    for elem in rates:  # I could extract the rates?
                        if elem[0] == ion(cycle[n if i else m]):
                            i = ordering.index(cycle[n])
                            j = ordering.index(cycle[m])  # creates diagonal of matrix
                            rate_mat[j, j] += -self.str_to_float(elem[self.reactions.index(self.nuc_change) + 1])
                            rate_mat[i, j] += self.str_to_float(elem[self.reactions.index(self.nuc_change) + 1])
                            break
        return rate_mat

    def eigen_sol2(self, isotope, show_eigen=False):
        mat = self.construct_rate_mat_2(isotope)
        order = self.order_iso(isotope, cycle=0)
        eig_val, eig_vec = np.linalg.eig(mat)
        size = len(mat) - 1

        def solution(t, show_order=False):
            if show_order:
                return [self.create_soln(eig_val, eig_vec, size, t), order]
            else:
                return self.create_soln(eig_val, eig_vec, size, t)

        if show_eigen:
            return solution, eig_val, eig_vec
        else:
            return solution

    def eigen_sol(self, cycle, show_eigen=False):
        mat = self.construct_rate_mat(cycle)
        order = self.order_iso(cycle)
        eig_val, eig_vec = np.linalg.eig(mat)
        size = len(mat) - 1

        def solution(t, show_order=False):
            if show_order:
                return [self.create_soln(eig_val, eig_vec, size, t), order]
            else:
                return self.create_soln(eig_val, eig_vec, size, t)

        if show_eigen:
            return solution, eig_val, eig_vec
        else:
            return solution

# this information is found where?
# make function for common cycles?
# how to automate this?
