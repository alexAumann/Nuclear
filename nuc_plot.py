import re
import numpy as np
from isotope import ion
import matplotlib.pyplot as plt
from functools import partial


# size of the cycle should be the number of distinct isotopes

class Nuclear:
    # redo this so it's aligned with other conventions
    # [ng, -ng, pn, -pn, beta, beta+, pg, -pg, ap, -ap, an, -an, ag, -ag]
    # [N, Z, A] for sublist
    # all forward reactions
    # two stable nuclei with Z > N?
    # positive indicates capture
    # negative indicates emission
    # TODO Extract mass fractions
    reactions = [[1, 0, 1], [-1, 0, -1],
                 # have (p,n) reactions at a later time
                 [-1, 1, 0], [1, -1, 0],
                 [0, 1, 1], [0, -1, -1],
                 [2, 1, 3], [-2, -1, -3],
                 [1, 2, 3], [-1, -2, -3],
                 [2, 2, 4], [-2, -2, -4]]
    # This is a crude implementation for the nuclear reactions
    ng = {str([1, 0, 1]): [-1, 0, 0], str([-1, 0, -1]): [1, 0, 0]}
    # pn = [[-1, 1, 0], [1, -1, 0]]
    # neutron proton alpha
    beta = {str([-1, 1, 0]): [1, -1, 0], str([1, -1, 0]): [-1, 1, 0]}
    pg = {str([0, 1, 1]): [0, -1, 0], str([0, -1, -1]): [0, 1, 0]}
    ap = {str([2, 1, 3]): [0, 1, -1], str([-2, -1, -3]): [0, -1, 1]}
    an = {str([1, 2, 3]): [1, 0, -1], str([-1, -2, -3]): [0, -1, 1]}
    ag = {str([2, 2, 4]): [0, 0, -1], str([-2, -2, -4]): [0, 0, 1]}
    neutron = [[1, 0, 1], [-1, 0, -1], [1, 2, 3], [-1, -2, -3], [-1, 1, 0], [1, -1, 0]]
    proton = [[0, 1, 1], [0, -1, -1], [2, 1, 3], [-2, -1, -3], [-1, 1, 0], [1, -1, 0]]
    alpha = [[2, 1, 3], [-2, -1, -3], [1, 2, 3], [-1, -2, -3], [2, 2, 4], [-2, -2, -4]]

    def __init__(self, starshot):
        """
        :param data: .flowb data generated by the Shot class
        """
        self.flowb = starshot.flowb
        self.tn = starshot.tn
        self.nuc_change = [0, 0, 0]

    def split_numbers(self, number):
        for i in range(len(number) - 1, -1, -1):
            if number[i] == "-":
                if i == 0:
                    return [number]
                elif number[i - 1] == "E":
                    continue
                else:
                    return self.split_numbers(number[:i]) + [number[i:]]
            elif i == 0:
                return [number]

    @staticmethod
    def str_to_float(val):
        """
        Ensures that numerical data is in the appropriate format

        :param val: A string to be converted into numerical data of proper form
        :return:
        """
        return float(re.sub(r"(\d)([+-])", r"\1E\2", val))

    def check_nucleus(self):
        result = []
        if self.nuc_change in self.neutron:
            result.append(0)
        if self.nuc_change in self.proton:
            result.append(1)
        if self.nuc_change in self.alpha:
            result.append(2)
        if len(result):
            return result
        else:
            raise Exception("Change in nucleus may be incorrect:", str(self.nuc_change))

    def check_priority(self):
        if self.nuc_change[1] < 0 or self.nuc_change[2] < 0:
            return 1
        else:
            return 0

    @staticmethod
    def order_iso(lst, cycle=1):
        """
        This method returns a list which is ordered by nucleus of lower Z or lower A, in the priority

        :param lst: A lst of strings which represent elements, for example
            ['C12', 'N13', 'C13', 'N14', 'O15', 'N15', 'C12']
        :param cycle: cycle = 1 implies that this is a cycle, cycle = 0 implies that
            this is not a cycle
        :return: returns a list which is ordered by nucleus of lower Z or lower A, in the priority
        """
        if cycle == 1 and lst[0] != lst[-1]:
            raise Exception("This is not a cycle")
        if cycle != 0 and cycle != 1:
            raise ValueError("Cycle can only have value of 1 or 0")
        output = lst[:None if cycle == 0 else -cycle]
        output = sorted(output, key=lambda x: (ion(x).Z, ion(x).A))
        return output

    # coefficients of the exponential terms haven't been determined yet
    def create_soln(self, eig_val, eig_vec, size, t):
        """
        A helper method which creates the time dependent solution from the eigenvector analysis of nuclear reaction
         cycles. This is done by recursion.

        :param eig_val: List of eigenvalues. Eigenvalues and eigenvectors need to occupy the same position in the list.
        :param eig_vec: List of eigenvectors. Eigenvalues and eigenvectors need to occupy the same position in the list.
        :param size: The size of the cycle i.e., how many distinct isotopes are there in the cycle?
        :param t: A parameter which represents time in ... . This parameter needn't be defined when creating the
            solution function
        :return: returns the time dependent solution.
        """
        if size == 0:
            return eig_vec[:, size] * np.exp(eig_val[size] * t)
        else:
            return eig_vec[:, size] * np.exp(eig_val[size] * t) + self.create_soln(eig_val, eig_vec, size - 1, t)

    def get_mass_fractions(self, zone):
        """
        Extracts the mass fractions from the attribute data.
        :return: the mass fractions as a list of strings.
        """
        mass_fractions = None
        index = None
        for i, l in enumerate(self.flowb[zone]):
            if l.find('MASS FRACTIONS') > 0:
                index = i + 1
            if l.find('PARTITION FUNCTION') > 0:
                mass_fractions = self.flowb[zone][index:i]
                break
        mass_fractions = [i for i in mass_fractions for i in i.split() if len(i) > 0]
        return mass_fractions[:len(mass_fractions)]

    # Flows aren't extracted properly as some entries in the same row aren't separated by ' '
    def get_flows(self, zone):
        """
        Extracts the === FLOWS === data from the attribute data.
        :return: the flow data as a list.
        """
        flows = None
        index = None
        for i, l in enumerate(self.flowb[zone]):
            if l.find('== FLOWS ==') > 0:
                index = i + 1
            if l.find('== RATES ==') > 0:
                flows = self.flowb[zone][index:i]
                break
        flows = [i.split() for i in flows if len(i) > 0]
        flows[2].insert(1, '')  # to be changed
        return flows[:len(flows) - 1]

    def get_rates(self, zone):
        # would be nice to construct the list correctly the first time around in list comprehension
        """
        Extracts the === RATES === data from the attribute data
        :return: the rates data as a list
        """
        rates = None
        for i, l in enumerate(self.flowb[zone].splitlines()):
            if l.find('== RATES ==') > 0:
                rates = self.flowb[zone].splitlines()[i + 1:]
                break
        rates = [i.split() for i in rates if len(i) > 0]
        for rate_index in range(1, len(rates)):
            row = []
            if len(rates[rate_index]) < 15:
                for rate_val in rates[rate_index]:
                    row += self.split_numbers(rate_val)
                rates[rate_index] = row
        return rates

    def check_rates(self, zone):
        """
        Function which checks if there are any outstanding errors with the forward and reverse rates
        :return: Returns a string if there are no errors, otherwise returns a list of the errors
        """
        rates = self.get_rates(zone)
        check = []
        for elem in rates[2:-1]:
            for i in range(7):
                if self.str_to_float(elem[1 + 2 * i]) - \
                        self.str_to_float(elem[2 + 2 * i]) > self.str_to_float(elem[1 + 2 * i]):
                    check.append(elem)
        if len(check) == 0:
            return "No critical errors"
        else:
            return check

    # may expand this to incorporate any CNO cycle
    def construct_cno1_mat(self, zone):
        # ignores (p, n) reactions, will add a default argument for this later
        cno1 = ['C12', 'N13', 'C13', 'N14', 'O15', 'N15', 'C12']
        ordering = self.order_iso(cno1)
        rate_mat = np.zeros((6, 6))
        # gets rid of n-p reactions
        rates = np.delete(np.array(self.get_rates(zone)[1:]), [3, 4], 1)
        for n in range(6):
            # looks at the change in nucleus (final - initial)
            self.nuc_change[0] = ion(cno1[n + 1]).N - ion(cno1[n]).N
            self.nuc_change[1] = ion(cno1[n + 1]).Z - ion(cno1[n]).Z
            self.nuc_change[2] = ion(cno1[n + 1]).A - ion(cno1[n]).A
            # checks for lower Z, then lower A
            # looks at the next isotope for reaction information with i = 1
            i = self.check_priority()
            for elem in rates:  # I could extract the rates?
                if elem[0] == ion(cno1[n + i]):
                    i = ordering.index(cno1[n + 1])
                    j = ordering.index(cno1[n])  # creates diagonal of matrix
                    rate_mat[j, j] = -self.str_to_float(elem[self.reactions.index(self.nuc_change) + 1])
                    rate_mat[i, j] = self.str_to_float(elem[self.reactions.index(self.nuc_change) + 1])
                    break
        return rate_mat

    # considers only basic reaction atm ?
    # format is [ng, -ng, pn, -pn, beta, -beta, pg, -pg, ap, -ap, an, -an, ag, -ag]
    # have to worry about branching at some point
    # make function which make the matrix
    # get another function to do eigen_check

    def construct_rate_mat(self, cycle, zone):
        """
        :param zone:
        :param cycle: List of strings which indicates the cycle, for example
            ['C12', 'N13', 'C13', 'N14', 'O15', 'N15', 'C12']
        :return: eigenvalues and eigenvectors?
        """
        ordering = self.order_iso(cycle)
        rate_mat = np.zeros((len(ordering), len(ordering)))
        rates = np.delete(np.array(self.get_rates(zone)[1:]), [3, 4], 1)
        for n in range(len(ordering)):
            # looks at the change in nucleus (final - initial)
            self.nuc_change[0] = ion(cycle[n + 1]).N - ion(cycle[n]).N
            self.nuc_change[1] = ion(cycle[n + 1]).Z - ion(cycle[n]).Z
            self.nuc_change[2] = ion(cycle[n + 1]).A - ion(cycle[n]).A
            # checks for lower Z, then lower A
            # looks at the next isotope for reaction information with i = 1
            i = self.check_priority()
            for elem in rates:  # I could extract the rates?
                if elem[0] == ion(cycle[n + i]):
                    i = ordering.index(cycle[n + 1])
                    j = ordering.index(cycle[n])  # creates diagonal of matrix
                    rate_mat[j, j] = -self.str_to_float(elem[self.reactions.index(self.nuc_change) + 1])
                    rate_mat[i, j] = self.str_to_float(elem[self.reactions.index(self.nuc_change) + 1])
                    break
        return rate_mat

    def rate_mat_branching(self, cycle, zone):
        """
        :param zone:
        :param cycle: List of strings which indicates the cycle, for example
            ['C12', 'N13', 'C13', 'N14', 'O15', 'N15', 'C12']
        :return: eigenvalues and eigenvectors?
        """
        ordering = self.order_iso(list(cycle.keys()), cycle=0)
        rate_mat = np.zeros((len(ordering), len(ordering)))
        rates = np.delete(np.array(self.get_rates(zone)[1:]), [3, 4], 1)
        for n in ordering:
            for m in range(len(cycle[n])):
                # looks at the change in nucleus (final - initial)
                self.nuc_change[0] = ion(cycle[n][m]).N - ion(n).N
                self.nuc_change[1] = ion(cycle[n][m]).Z - ion(n).Z
                self.nuc_change[2] = ion(cycle[n][m]).A - ion(n).A
                # checks for lower Z, then lower A
                # looks at the next isotope for reaction information with i = 1
                i = self.check_priority()
                for elem in rates:  # I could extract the rates?
                    if i == 1:
                        if elem[0] == ion(cycle[n][m]):
                            i = ordering.index(cycle[n][m])
                            j = ordering.index(n)  # creates diagonal of matrix
                            rate_mat[j, j] += -self.str_to_float(elem[self.reactions.index(self.nuc_change) + 1])
                            rate_mat[i, j] += self.str_to_float(elem[self.reactions.index(self.nuc_change) + 1])
                    else:
                        if elem[0] == ion(n):
                            i = ordering.index(cycle[n][m])
                            j = ordering.index(n)  # creates diagonal of matrix
                            rate_mat[j, j] += -self.str_to_float(elem[self.reactions.index(self.nuc_change) + 1])
                            rate_mat[i, j] += self.str_to_float(elem[self.reactions.index(self.nuc_change) + 1])
        return rate_mat

    def get_equilibrium(self, cycle, zone):
        mat = self.rate_mat_branching(cycle, zone)
        eig_val, eig_vec = np.linalg.eig(mat)
        coeff = np.linalg.solve(eig_vec, np.array([1 / len(eig_val)] * len(eig_val)))
        eq_index = np.where(abs(eig_val) == min(abs(eig_val)))
        res = coeff[eq_index] * eig_vec[:, eq_index].flatten()
        return res

    @staticmethod
    def find_suitable_temp(data):
        index = None
        for i in range(len(data)):
            if data[i] < 1 * 10 ** 7:
                index = i
                break
        return index

    def construct_equilibrium_data(self, cycle):
        zones = []
        equilibrium = []
        for i in range(1, len(self.flowb) - 1):
            zones.append(i)
            equilibrium.append(self.get_equilibrium(cycle, i))
        index = self.find_suitable_temp(self.tn[zones])
        return np.array(zones[:index]), np.array(equilibrium[:index])

    def plot_equilibrium(self, cycle, separate_plots=False):
        zones, equilibrium = self.construct_equilibrium_data(cycle)
        if separate_plots:
            num = np.floor(len(equilibrium[0])/3)
            plt.rcParams["figure.figsize"] = [12, 8]
            for i in range(len(equilibrium[0])):
                plt.subplot(int(num), 3, i + 1)
                plt.plot(zones, equilibrium[:, i])
                plt.xlim([self.tn[zones[-1]], self.tn[zones[0]]])
                plt.ylim([0, max(equilibrium[:, i])])
                plt.xlabel(r'temperature ($\mathrm{K}$)')
                plt.ylabel(r'relative abundance')
                plt.legend(self.order_iso(list(cycle.keys()), cycle=0)[i], loc='best')
                plt.tight_layout()
                plt.show()
        else:
            plt.plot(self.tn[zones][::-1], equilibrium[::-1])
            plt.xlim([self.tn[zones[-1]], self.tn[zones[0]]])
            plt.ylim([0, 1.1])
            plt.xlabel(r'temperature ($\mathrm{K}$)')
            plt.ylabel(r'relative abundance')
            plt.legend(self.order_iso(list(cycle.keys()), cycle=0), loc='best')
            plt.tight_layout()
            plt.show()

    def eigen_sol2(self, cycle, zone, show_eigen=False):
        mat = self.rate_mat_branching(cycle, zone)
        order = self.order_iso(list(cycle.keys()), cycle=0)
        eig_val, eig_vec = np.linalg.eig(mat)
        size = len(mat) - 1

        def solution(t, show_order=False):
            if show_order:
                return [self.create_soln(eig_val, eig_vec, size, t), order]
            else:
                return self.create_soln(eig_val, eig_vec, size, t)

        if show_eigen:
            return solution, eig_val, eig_vec
        else:
            return solution

    def eigen_sol(self, cycle, zone, show_eigen=False):
        mat = self.construct_rate_mat(cycle, zone)
        order = self.order_iso(cycle)
        eig_val, eig_vec = np.linalg.eig(mat)
        size = len(mat) - 1

        def solution(t, show_order=False):
            if show_order:
                return [self.create_soln(eig_val, eig_vec, size, t), order]
            else:
                return self.create_soln(eig_val, eig_vec, size, t)

        if show_eigen:
            return solution, eig_val, eig_vec
        else:
            return solution

# this information is found where?
# make function for common cycles?
# how to automate this?
